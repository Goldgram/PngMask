<style>
/*#svgClass {
  width: 240px;
  height: 240px;
  background-image: url("hex.jpg");
  background-size: contain;
}
#hexClass:hover {
	cursor: pointer;
	fill: green;
	fill-opacity: 0;
}
.hover {
  cursor: pointer;
}
#charizard:hover {
  fill: red;
  opacity: 0.5;
}*/
#charizard {
  border: 1px solid grey;
  cursor: pointer;
}
#charizard:hover {
  opacity: 0.5;
}
.mask {
  fill: black;
}
.mask:hover {
  cursor: pointer;
  fill-opacity: 0;
}
</style>

<!-- <svg id="svgClass" viewBox="0 0 240 240" xmlns="http://www.w3.org/2000/svg">
  <polygon id="hexClass" points="64,23 177,23 235,121 177,219 64,219 7,121"></polygon>
</svg> -->

<!-- <img src="test.png"> -->
<!-- <img id="hexImage" src="hex.png"> -->
<!-- <img id="charizard" src="charizard.png"> -->
<!-- <img class="pokemon" src="006.png"> -->
<img class="pokemon" src="007.png">
<img class="pokemon" src="063.png">
<!-- <img class="pokemon" src="092.png">
<img class="pokemon" src="093.png"> -->
<!-- <img id="plusImage" src="plus.png"> -->
<!-- <img id="testImage" src="y.png"> -->












<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
<script>
	// $("#hexClass").click(function() {
	//   console.log("hex click");
	// });

 //  $(function() {
    // $("img").mousemove(function(e) {
        
    //   if(!this.canvas) {
    //       this.canvas = $("<canvas />")[0];
    //       this.canvas.width = this.width;
    //       this.canvas.height = this.height;
    //       this.canvas.getContext("2d").drawImage(this, 0, 0, this.width, this.height);
    //   }
      
    //   var pixelData = this.canvas.getContext("2d").getImageData(event.offsetX, event.offsetY, 1, 1).data;
    //   var testData = this.canvas.getContext("2d");
      
    //   console.log("RGBA: " + pixelData[0] + ", " + pixelData[1] + ", " + pixelData[2] + ", " + pixelData[3]);
    // });
    // renderMap("plusImage");
    // renderMap("hexImage");
    // renderMap("charizard");

   
  // });

//   function renderMap(imageId) {
//     var image = $("#"+imageId)[0];
//     var canvas = $("<canvas />")[0];
//     canvas.width = image.width;
//     canvas.height = image.height;
//     canvas.getContext("2d").drawImage(image, 0, 0, image.width, image.height);
    
//     // console.log("data: ");
//     var svgString = '<svg style="width: '+image.width+'px;height: '+image.height+'px;background-size: contain;background-image: url('+$("#"+imageId).attr("src")+');" viewBox="0 0 '+image.width+' '+image.height+'" xmlns="http://www.w3.org/2000/svg">';
// //   <polygon id="hexClass" points="64,23 177,23 235,121 177,219 64,219 7,121"></polygon>
// // 
//     // string = "";
//     for (var x = 0; x < image.width; x++) {
//       for (var y = 0; y < image.height; y++) {
//         var alpha = canvas.getContext("2d").getImageData(x, y, 1, 1).data[3];
//         if (alpha > 0) {
//           // string += " "+x+","+y;
//           svgString += '<rect class="hover" x="'+x+'" y="'+y+'" width="1" height="1" style="fill:blue;fill-opacity:0;"/>';//
//         }
//       }
//     }
//     svgString += '</svg>';
//     $("body").append(svgString);
//   }
// var imageArray = [
//   [0,0,0,0,0],
//   [0,1,0,1,0],
//   [0,1,1,1,0],
//   [0,0,1,0,0],
//   [0,0,0,0,0]
// ];

//x, y map
// // 0:-1,-1  1:-1,0  2:-1,1
// // 7:0,-1   X:0,0   3:0,1
// // 6:1,-1   5:1,0   4:1,1
// var directions = [
//   {x:-1,y:-1},
//   {x:-1,y:0},
//   {x:-1,y:1},
//   {x:0,y:1},
//   {x:1,y:1},
//   {x:1,y:0},
//   {x:1,y:-1},
//   {x:0,y:-1}
// ];

// 0:-1,-1  1:0,-1  2:1,-1
// 7:-1,0   X:0,0   3:1,0
// 6:-1,1   5:0,1   4:1,1
// var directions = [
//   {x:-1,y:-1},
//   {x:0,y:-1},
//   {x:1,y:-1},
//   {x:1,y:0},
//   {x:1,y:1},
//   {x:0,y:1},
//   {x:-1,y:1},
//   {x:-1,y:0}
// ];

// var pixelTolerance = 1;



// var currentNode = {x:1, y:1};
// for (var i = 0; i < 8; i++) {
//   var value = getSiblingSolid(currentNode, i);
//   console.log(value);
// }

// console.log(getSiblingSolid(currentNode, 0));
// console.log(getSiblingSolid(currentNode, 2));
// console.log(getSiblingSolid(currentNode, 4));
// console.log(getSiblingSolid(currentNode, 6));


// var alphaTolerance = 100;
// var pathDirection = {
//   "up": {left:0, leftCorner:"bottomLeft", leftString:"left", straight:1, straightCorner:"topLeft", rightCorner:"topRight", rightString:"right"},
//   "right": {left:2, leftCorner:"topLeft", leftString:"up", straight:3, straightCorner:"topRight", rightCorner:"bottomRight", rightString:"down"},
//   "down": {left:4, leftCorner:"topRight", leftString:"right", straight:5, straightCorner:"bottomRight", rightCorner:"bottomLeft", rightString:"left"},
//   "left": {left:6, leftCorner:"bottomRight", leftString:"down", straight:7, straightCorner:"bottomLeft", rightCorner:"topLeft", rightString:"up"},
// };
// var image;
// var canvas;
// var startingPath;
// var paths = "";

// function createCanvas(image) {
//   canvas = document.createElement('canvas');
//   canvas.width = image.width;
//   canvas.height = image.height;
//   canvas.getContext("2d").drawImage(image, 0, 0, image.width, image.height);
// }
// function isSolidNode(node) {
//   var alpha = canvas.getContext("2d").getImageData(node.x, node.y, 1, 1).data[3];
//   return alpha > alphaTolerance;
// }

// function getSiblingNode(node, directionsId) {
//   var dirX = directions[directionsId].x*pixelTolerance;
//   var dirY = directions[directionsId].y*pixelTolerance;
//   return {x:node.x+dirX, y:node.y+dirY};
// }

// function getCornerString(node, cornerString) {
//   var distance = 1*pixelTolerance;
//   switch (cornerString) {
//     case "topLeft":
//       return " "+node.x+","+node.y;
//     case "bottomLeft":
//       return " "+node.x+","+(node.y+distance);
//     case "topRight":
//       return " "+(node.x+distance)+","+node.y;
//     case "bottomRight":
//       return " "+(node.x+distance)+","+(node.y+distance);
//   }
// }

// function findNextNode(node, pathString) {
//   var results;
//   var dir = pathDirection[pathString];
//   var leftNode = getSiblingNode(node, dir.left);

//   var straightNode = getSiblingNode(node, dir.straight);
//   if (!isSolidNode(straightNode)) {
//     results = [node, dir.rightCorner, dir.rightString];
//   } else {
//     var leftNode = getSiblingNode(node, dir.left);
//     if (!isSolidNode(leftNode)) {
//       results = [straightNode, dir.straightCorner, pathString];
//     } else {
//       results = [leftNode, dir.leftCorner, dir.leftString];
//     }
//   }
//   var newPath = getCornerString(results[0], results[1]);
//   if (newPath === startingPath) {
//     return {status:"complete"};
//   }
//   paths += newPath;
//   return {node:results[0], dir:results[2]};
// }

// function createPolygon(image) {
//   image = image;
//   createCanvas(image);

//   var halfHeight = Math.floor(image.height/2);
//   var startingNode = {x:0, y:halfHeight};
  

//   while (startingNode.x < image.width) {
//     if (isSolidNode(startingNode)) {
//       startingPath = paths = getCornerString(startingNode, "bottomLeft");
//       paths += getCornerString(startingNode, "topLeft");
//       break;
//     }
//     startingNode.x++;
//   }

//   var results = {node:startingNode, dir:"up"};
//   while (results.status !== "complete") {
//     results = findNextNode(results.node, results.dir);
//   }
//   renderPolygon();
// }
// function renderPolygon(element) {
//   // console.log("paths: "+paths);
//   var svgString = '<svg style="width: '+element.width+'px;height: '+element.height+'px;background-size: contain;background-repeat: no-repeat;background-position: center; background-image: url('+element.getAttribute("src")+');" viewBox="0 0 '+element.width+' '+element.height+'" xmlns="http://www.w3.org/2000/svg">';
//   svgString +=      '<polygon class="mask" points="'+self.imageVars[element.src].paths+'"></polygon>';
//   svgString +=    '</svg>';

 
//   $("body").append(svgString);
//   // document.body.appendChild(myElement);// need to turn string into element
// }


// class
var PngMask = function(className, options) {
  var self = this;
  this.mappingTolerance = options && options.mappingTolerance || 1;
  this.alphaTolerance = options && options.alphaTolerance || 80;

  this.imageVars = {};
  var directions = [
    {x:-1,y:-1},
    {x:0,y:-1},
    {x:1,y:-1},
    {x:1,y:0},
    {x:1,y:1},
    {x:0,y:1},
    {x:-1,y:1},
    {x:-1,y:0}
  ];
  var pathDirection = {
    "up": {left:0, leftCorner:"bottomLeft", leftString:"left", straight:1, straightCorner:"topLeft", rightCorner:"topRight", rightString:"right"},
    "right": {left:2, leftCorner:"topLeft", leftString:"up", straight:3, straightCorner:"topRight", rightCorner:"bottomRight", rightString:"down"},
    "down": {left:4, leftCorner:"topRight", leftString:"right", straight:5, straightCorner:"bottomRight", rightCorner:"bottomLeft", rightString:"left"},
    "left": {left:6, leftCorner:"bottomRight", leftString:"down", straight:7, straightCorner:"bottomLeft", rightCorner:"topLeft", rightString:"up"},
  };
  
  function imgLoaded(element) {
    return element.complete && element.naturalHeight !== 0;
  }

  function createCanvas(element) {
    var canvas = document.createElement('canvas');
    canvas.width = element.width;
    canvas.height = element.height;
    canvas.getContext("2d").drawImage(element, 0, 0, element.width, element.height);
    self.imageVars[element.src].canvas = canvas;
  }

  function isSolidNode(element, node) {
    var alpha = self.imageVars[element.src].canvas.getContext("2d").getImageData(node.x, node.y, 1, 1).data[3];
    return alpha > self.alphaTolerance;
  }

  function getCornerString(node, cornerString) {
    switch (cornerString) {
      case "topLeft":
        return " "+node.x+","+node.y;
      case "bottomLeft":
        return " "+node.x+","+(node.y+self.mappingTolerance);
      case "topRight":
        return " "+(node.x+self.mappingTolerance)+","+node.y;
      case "bottomRight":
        return " "+(node.x+self.mappingTolerance)+","+(node.y+self.mappingTolerance);
    }
  }

  function getSiblingNode(node, directionsId) {
    var dirX = directions[directionsId].x*self.mappingTolerance;
    var dirY = directions[directionsId].y*self.mappingTolerance;
    return {x:node.x+dirX, y:node.y+dirY};
  }

  function findNextNode(element, node, pathString) {
    var results;
    var dir = pathDirection[pathString];
    var leftNode = getSiblingNode(node, dir.left);

    var straightNode = getSiblingNode(node, dir.straight);
    if (!isSolidNode(element, straightNode)) {
      results = [node, dir.rightCorner, dir.rightString];
    } else {
      var leftNode = getSiblingNode(node, dir.left);
      if (!isSolidNode(element, leftNode)) {
        results = [straightNode, dir.straightCorner, pathString];
      } else {
        results = [leftNode, dir.leftCorner, dir.leftString];
      }
    }
    var newPath = getCornerString(results[0], results[1]);
    if (newPath === self.imageVars[element.src].startingPath) {
      return {status:"complete"};
    }
    self.imageVars[element.src].paths += newPath;
    return {node:results[0], dir:results[2]};
  }

  function renderPolygon(element) {
    var svgString = '<svg style="width: '+element.width+'px;height: '+element.height+'px;background-size: contain;background-repeat: no-repeat;background-position: center; background-image: url('+element.getAttribute("src")+');" viewBox="0 0 '+element.width+' '+element.height+'" xmlns="http://www.w3.org/2000/svg">';
    svgString +=      '<polygon class="mask" points="'+self.imageVars[element.src].paths+'"></polygon>';
    svgString +=    '</svg>';
    // document.body.appendChild(svgString);
    $("body").append(svgString);
    return svgString;
    // document.body.appendChild(myElement);// need to turn string into element
  }

  function createPolygon(element) {
    self.imageVars[element.src] = {
      startingPath: "",
      paths: ""
    };
    createCanvas(element);

    var halfHeight = Math.floor(element.height/2);
    var startingNode = {x:0, y:halfHeight};
    

    while (startingNode.x < element.width) {
      if (isSolidNode(element, startingNode)) {
        self.imageVars[element.src].startingPath = self.imageVars[element.src].paths = getCornerString(startingNode, "bottomLeft");
        self.imageVars[element.src].paths += getCornerString(startingNode, "topLeft");
        break;
      }
      startingNode.x++;
    }
    var results = {node:startingNode, dir:"up"};
    while (results.status !== "complete") {
      results = findNextNode(element, results.node, results.dir);
    }
    return renderPolygon(element);
  }



  // create promise for the resulted svg
  return new Promise(function(resolve, reject) {
    var elements = document.getElementsByClassName(className);
    if (!elements.length) {
      return reject("cannot find class: "+className);
    }
    var masksBySrc = {};
    var promiseArray = [];
    for (var i = 0; i < elements.length; i++) {
      var element = elements[i];
      element.src = element.getAttribute("src");
      // var src = element.getAttribute("src");
      if (!masksBySrc[element.src]) {
        promiseArray.push(new Promise(function(resolve, reject) {
          function waitForImageToLoad(element) {
            setTimeout(function(){
              if (imgLoaded(element)) {
                masksBySrc[element.src] = createPolygon(element);
                // console.log(element.src+" done!");
                return resolve(masksBySrc[element.src]);
              }
              waitForImageToLoad(element);
            }, 1000);
          }
          if (imgLoaded(element)) {
            masksBySrc[element.src] = createPolygon(element);
            // console.log(element.src+" done!");
            return resolve(masksBySrc[element.src]);
          }
          waitForImageToLoad(element);
        }));
      }
    }
    return Promise.all(promiseArray).then(function(values) { 
      return resolve(masksBySrc);
    });
  });
};

$(function() {
  
  var maskOne = new PngMask('pokemon');
  maskOne.then(function(data){
    console.log("Success - "+JSON.stringify(data));
  },function(error){
    console.log("Error - "+error);
  });
  
});
</script>