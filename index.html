<style>
/*#svgClass {
  width: 240px;
  height: 240px;
  background-image: url("hex.jpg");
  background-size: contain;
}
#hexClass:hover {
	cursor: pointer;
	fill: green;
	fill-opacity: 0;
}
.hover {
  cursor: pointer;
}
#charizard:hover {
  fill: red;
  opacity: 0.5;
}*/
#charizard {
  border: 1px solid grey;
  cursor: pointer;
}
#charizard:hover {
  opacity: 0.5;
}
.mask {
  fill: black;
}
.mask:hover {
  cursor: pointer;
  fill-opacity: 0;
}
</style>

<!-- <svg id="svgClass" viewBox="0 0 240 240" xmlns="http://www.w3.org/2000/svg">
  <polygon id="hexClass" points="64,23 177,23 235,121 177,219 64,219 7,121"></polygon>
</svg> -->

<!-- <img src="test.png"> -->
<!-- <img id="hexImage" src="hex.png"> -->
<!-- <img id="charizard" src="charizard.png"> -->
<!-- <img class="pokemon" src="006.png"> -->
<img class="pokemon" src="007.png">
<img class="pokemon" src="063.png">
<!-- <img class="pokemon" src="092.png">
<img class="pokemon" src="093.png"> -->
<!-- <img id="plusImage" src="plus.png"> -->
<!-- <img id="testImage" src="y.png"> -->












<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
<script>
// class
var PngMask = function(className, options) {
  var self = this;
  var directions = [
    {x:-1,y:-1},
    {x:0,y:-1},
    {x:1,y:-1},
    {x:1,y:0},
    {x:1,y:1},
    {x:0,y:1},
    {x:-1,y:1},
    {x:-1,y:0}
  ];
  var pathDirection = {
    "up": {left:0, leftCorner:"bottomLeft", leftString:"left", straight:1, straightCorner:"topLeft", rightCorner:"topRight", rightString:"right"},
    "right": {left:2, leftCorner:"topLeft", leftString:"up", straight:3, straightCorner:"topRight", rightCorner:"bottomRight", rightString:"down"},
    "down": {left:4, leftCorner:"topRight", leftString:"right", straight:5, straightCorner:"bottomRight", rightCorner:"bottomLeft", rightString:"left"},
    "left": {left:6, leftCorner:"bottomRight", leftString:"down", straight:7, straightCorner:"bottomLeft", rightCorner:"topLeft", rightString:"up"},
  };

  this.mappingTolerance = options && options.mappingTolerance || 1;
  this.alphaTolerance = options && options.alphaTolerance || 80;
  this.replaceImage = options && options.replaceImage || true;
  this.imageVars = {};
  
  
  function imgLoaded(element) {
    return element.complete && element.naturalHeight !== 0;
  }

  function createCanvas(element) {
    var canvas = document.createElement('canvas');
    canvas.width = element.width;
    canvas.height = element.height;
    canvas.getContext("2d").drawImage(element, 0, 0, element.width, element.height);
    self.imageVars[element.src].canvas = canvas;
  }

  function isSolidNode(element, node) {
    var alpha = self.imageVars[element.src].canvas.getContext("2d").getImageData(node.x, node.y, 1, 1).data[3];
    return alpha > self.alphaTolerance;
  }

  function getCornerString(node, cornerString) {
    switch (cornerString) {
      case "topLeft":
        return " "+node.x+","+node.y;
      case "bottomLeft":
        return " "+node.x+","+(node.y+self.mappingTolerance);
      case "topRight":
        return " "+(node.x+self.mappingTolerance)+","+node.y;
      case "bottomRight":
        return " "+(node.x+self.mappingTolerance)+","+(node.y+self.mappingTolerance);
    }
  }

  function getSiblingNode(node, directionsId) {
    var dirX = directions[directionsId].x*self.mappingTolerance;
    var dirY = directions[directionsId].y*self.mappingTolerance;
    return {x:node.x+dirX, y:node.y+dirY};
  }

  function findNextNode(element, node, pathString) {
    var results;
    var dir = pathDirection[pathString];
    var leftNode = getSiblingNode(node, dir.left);

    var straightNode = getSiblingNode(node, dir.straight);
    if (!isSolidNode(element, straightNode)) {
      results = [node, dir.rightCorner, dir.rightString];
    } else {
      var leftNode = getSiblingNode(node, dir.left);
      if (!isSolidNode(element, leftNode)) {
        results = [straightNode, dir.straightCorner, pathString];
      } else {
        results = [leftNode, dir.leftCorner, dir.leftString];
      }
    }
    var newPath = getCornerString(results[0], results[1]);
    if (newPath === self.imageVars[element.src].startingPath) {
      return {status:"complete"};
    }
    self.imageVars[element.src].paths += newPath;
    return {node:results[0], dir:results[2]};
  }

  function renderPolygon(element) {
    var svgString = '<svg style="width: '+element.width+'px;height: '+element.height+'px;background-size: contain;background-repeat: no-repeat;background-position: center; background-image: url('+element.getAttribute("src")+');" viewBox="0 0 '+element.width+' '+element.height+'" xmlns="http://www.w3.org/2000/svg">';
    svgString +=      '<polygon class="mask" points="'+self.imageVars[element.src].paths+'"></polygon>';
    svgString +=    '</svg>';


    // var container = document.createElement("div");
    // container.innerHTML = svgString;

    // var svg = document.createElement("svg");
    // svg.width = element.width;
    // svg.height = element.height;
    // "width: '+element.width+'px;height: '++'pxsvg.setAttribute("style", "width: "+element.width+"px;height: "+element.height+"px");

    // svg.setAttribute("viewbox", "0 0 "+element.width+" "+element.height);
    // svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    // var polygon = document.createElement("svg");
    // polygon.setAttribute("style", "fill:red;");
    // polygon.setAttribute("points", self.imageVars[element.src].paths);
    // svg.appendChild(polygon);


    // container.appendChild(element);
    // svg.appendChild(polygon);
    // container.appendChild(svg);
    



    if (self.replaceImage) {

    //   element.parentNode.replaceChild(container, element);
    //   // document.body.appendChild(svgString);
      $("body").append(svgString);
    };
    return svgString;
    // document.body.appendChild(myElement);// need to turn string into element
  }

  function createPolygon(element) {
    self.imageVars[element.src] = {
      startingPath: "",
      paths: ""
    };
    createCanvas(element);

    var halfHeight = Math.floor(element.height/2);
    var startingNode = {x:0, y:halfHeight};
    
    while (startingNode.x < element.width) {
      if (isSolidNode(element, startingNode)) {
        self.imageVars[element.src].startingPath = self.imageVars[element.src].paths = getCornerString(startingNode, "bottomLeft");
        self.imageVars[element.src].paths += getCornerString(startingNode, "topLeft");
        break;
      }
      startingNode.x++;
    }
    var results = {node:startingNode, dir:"up"};
    while (results.status !== "complete") {
      results = findNextNode(element, results.node, results.dir);
    }
    // var newElement = renderPolygon(element);
    // if (self.replaceImage) {

    //   element.parentNode.replaceChild(newElement, element);
    //   // document.body.appendChild(svgString);
    //   // $("body").append(svgString);
    // };
    return renderPolygon(element);
  }



  // create promise for the resulted svg
  return new Promise(function(resolve, reject) {
    var elements = document.getElementsByClassName(className);
    if (!elements.length) {
      return reject("cannot find class: "+className);
    }
    var masksBySrc = {};
    var promiseArray = [];
    for (var i = 0; i < elements.length; i++) {
      var element = elements[i];
      element.src = element.getAttribute("src");
      if (!masksBySrc[element.src]) {
        promiseArray.push(new Promise(function(resolve, reject) {
          function waitForImageToLoad(element) {
            setTimeout(function(){
              if (imgLoaded(element)) {
                masksBySrc[element.src] = createPolygon(element);
                // console.log(element.src+" done!");
                return resolve(masksBySrc[element.src]);
              }
              waitForImageToLoad(element);
            }, 1000);
          }
          if (imgLoaded(element)) {
            masksBySrc[element.src] = createPolygon(element);
            // console.log(element.src+" done!");
            return resolve(masksBySrc[element.src]);
          }
          waitForImageToLoad(element);
        }));
      }
    }
    return Promise.all(promiseArray).then(function(values) { 
      return resolve(masksBySrc);
    });
  });
};

// class use!!!
var maskOne = new PngMask('pokemon');
maskOne.then(function(data){
  console.log("Success - "+JSON.stringify(data));
},function(error){
  console.log("Error - "+error);
});

</script>